import phpserialize

from django.utils import dateparse
from .workers import SiteCheckLogger
from .models import SiteCheck


import logging

console = logging.StreamHandler()
logger = logging.getLogger(__name__)


class LegacySiteCheckLogger(SiteCheckLogger):
    """
    A worker to consume messages from RabbiqMQ, generated by the
    enqueue library in the TGWF greencheck-api php app.

    Takes a PHP serialised data, and writes the necessary values
    to the greencheck logger tables.
    """

    php_dict = None

    def parse_serialised_php(self, body: bytes = None):
        """
        Accept a bytes string of encoded PHP, parses it returning
        a datastructure we can more easily parse
        """

        parsed_php = phpserialize.loads(body, object_hook=phpserialize.phpobject)
        result = parsed_php.get(b"result")
        self.php_dict = result._asdict()

        return self.php_dict

    def sitecheck_from_php_dict(self, body: bytes = None):
        """
        Accept a dict from parsed php, and return a datastructure without the name
        spacing.
        """
        self.parse_serialised_php(body)

        return SiteCheck(
            ip=self.prefixed_attr("ip"),
            url=self.prefixed_attr("checkedUrl"),
            data=self.prefixed_attr("data"),
            green=self.prefixed_attr("green"),
            cached=self.prefixed_attr("cached"),
            hosting_provider_id=self.prefixed_attr("idHostingProvider"),
            match_type=self.prefixed_attr("matchtype").get("type"),
            match_ip_range=self.prefixed_attr("matchtype").get("id"),
            checked_at=self.prefixed_attr("checkedAt"),
        )

    def prefixed_attr(self, key):
        """
        Returns the value, as an appropriate type based what we
        find matching `key` in our phpdict:
        """

        # we have no dict parsed yet, return early
        if self.php_dict is None:
            return None

        prefix = "\x00TGWF\\Greencheck\\SitecheckResult\x00"
        full_length_key = f"{prefix}{key}"

        # we need to use bytes rather than a string for our key
        res = self.php_dict.get(full_length_key.encode())

        logger.debug(key)

        if key == "checkedAt":
            return self.get_checked_at(res)

        if key == "matchtype":
            return self.get_match_type(res)

        return self.cast_from_php(res)

    def cast_from_php(self, res):
        """
        Accept a value, and based on the type, return the tidier representation
        """
        if isinstance(res, bytes):
            return res.decode("utf-8")

        if isinstance(res, bool):
            return res

        if isinstance(res, int):
            return res

        if isinstance(res, dict):
            cleaned_res = {}
            for key, val in res.items():
                cleaned_res[key.decode("utf-8")] = self.cast_from_php(val)
            if "ipv4" or "ipv6" in cleaned_res.keys():
                # return just the ip address
                single_ip, *_ = [v for k, v in cleaned_res.items() if v]
                return single_ip

    def get_match_type(self, res=None):
        """
        Return the match type passed in. Because we can't be sure
        that the checked IP range still exists, we need to extract it
        now, rather than re-fetching it when adding it to the greencheck
        table.
        """
        cleaned_res = {}
        for key, val in res.items():
            cleaned_res[key.decode("utf-8")] = self.cast_from_php(val)

        return cleaned_res

    def get_checked_at(self, res):
        """
        Return the date of the check. Because the date is
        a dict, we need to fetch only the value we need.
        """
        # coerce the <phpobject b'DateTime'> to a dict
        cleaned_res = {}

        for key, val in res._asdict().items():
            cleaned_res[key.decode("utf-8")] = self.cast_from_php(val)

        parsed_datetime = dateparse.parse_datetime(cleaned_res.get("date"))
        formatted_date = parsed_datetime.strftime("%Y-%m-%d %H:%M:%S")

        return formatted_date

    def parse_and_log_to_database(self, serialised_php):
        """
        Accept a message, like the kind sent over rabbitmq, and
        write it to the greencheck logging tables, as well as updating
        the green domain table if the checked site is green.
        """
        # fetch parse out our sitecheck
        sitecheck = self.sitecheck_from_php_dict(serialised_php)

        # log it our database and caches
        try:
            self.log_sitecheck_to_database(sitecheck)
        except Exception as err:
            logger.exception(f"Problem logging to our database: {err}")
